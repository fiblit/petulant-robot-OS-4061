/* CSci4061 Assignment 3
* name: Dalton Hildreth, Timothy Kohn
* id: hildr039, kohnx074 */

Outline (for us programmers):
"main":
	mkQueue on heap (could be after RDINPUT, if we do EC. I think.)
	RDINPUT
	mkDBMemStruct on heap
	mk & run threads -> see "PROCESSER" & "QUEUER"

"RDINPUT": (may or may not actually be a function)
	rd/validate args
	open/validate .in file
	READDB

"READDB":
	open twitterDB.txt //twitterDB = macro/#define
	rd twitterDB into DBMemStruct
	close twitterDB

"PROCESSER":
	check if queue has something <- semaphore!
	lock/wait mutex/semaphore to queue //there might be two more semaphores to deal with full/empty
	take item off of queue
	unlock/signal queue mutex/semaphore
	open item(.txt) (it's a file) }
	RD item's city                } Could be a function getCity(FILENAME)
	close item                    }
	search for city in DBMemStruct
	mk item.txt.result file
	write result to ^ file
	write \n to ^ file

"QUEUER": //As I understand it there should be one of these, potentially even in "main
	check if queue is not full <- semaphore!
		if it is full we need to print a message
	lock/wait mutex/semaphore to queue
	put next item on queue (<- seems to need a FILE I/O here. Bad.)
	unlock/signal queue mutex/semaphore

Needed data structures:
	Queue //A thinly disguised Linked-List for unbounded-ness //or perhaps an array because EC
	DBMem //Will start as array, but a hashtable would probably be best

